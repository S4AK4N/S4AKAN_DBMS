# Kotlinで学ぶ自作DBMS方針

## 目的
- **業務でのDB設計・運用力強化**
- **資格試験（応用情報・DBスペシャリスト）で必要な知識をショートカット**
- **SQL内部動作を実装ベースで理解**

---

## 学習の進め方（段階的ロードマップ）

### ステップ0: ブートストラップ（インメモリDB）
- REPLで `CREATE TABLE / INSERT / SELECT` を処理できる最小構成
- SQLパーサ → 実行計画 → 走査の流れを掴む
- 学び: **クエリ処理の基本**

### ステップ1: 永続化＆スロットページ
- テーブルデータをファイルに保存・復元
- ページサイズ4KB固定、スロットページ形式で管理
- 学び: **物理配置、VACUUMの意味**

### ステップ2: B+木インデックス
- `WHERE col = ?` が高速化されることを体感
- 範囲検索用にリーフノードを連結
- 学び: **インデックス最適化とExplain計画的思考**

### ステップ3: トランザクション & リカバリ
- `BEGIN / COMMIT / ROLLBACK` を実装
- 行ロック（S/X）＋ 2相ロック(2PL)
- WAL(Write-Ahead Logging) で耐障害性を確保
- 学び: **ACID特性、障害復旧、チェックポイントの意味**

---

## 実務・試験で活きる理解ポイント
- インデックス設計の勘所（選択性・複合キー）
- 正規化と非正規化のトレードオフ
- トランザクション制御（ロック・デッドロック）
- 障害復旧（WAL、REDO/UNDO）
- クエリチューニングの勘所

---

## 補助教材
- [SQLite Architecture](https://www.sqlite.org/arch.html)
- MIT 6.830 Database Systems（演習教材）
- 『データベース実践入門』（翔泳社）

---

## 進め方のコツ（Kotlinならでは）
- データクラス / sealed class で AST や実行計画を安全に表現
- Java NIO の `ByteBuffer` / `MappedByteBuffer` でページI/Oを扱う
- Coroutines は後回し（ロックと組み合わせると混乱しやすい）

---

## 将来的な伸びしろ
- 複合インデックス、範囲クエリ最適化
- MVCC（スナップショット分離の簡易版）
- JDBCドライバもどき実装
- 統計情報によるコストベース最適化

---